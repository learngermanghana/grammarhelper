<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Falowen â€” Speak & Upload</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 20px; }
        .card { max-width: 640px; margin: 0 auto; padding: 16px; border: 1px solid #e5e7eb; border-radius: 12px; }
        button { padding: 10px 14px; border-radius: 10px; border: 1px solid #d1d5db; background: #111827; color: #fff; cursor: pointer; }
        button[disabled] { opacity: .5; cursor: not-allowed; }
        .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
        .note { font-size: 14px; color: #374151; }
        progress { width: 100%; height: 12px; }
        .ok { color: #065f46; }
        .warn { color: #92400e; }
        .err { color: #991b1b; }
        .pill { display:inline-block; padding:4px 8px; border:1px solid #d1d5db; border-radius:999px; font-size:12px; }
    </style>
</head>
<body>
<div class="card">
    <h2>ðŸŽ¤ Falowen â€” Speak & Upload</h2>

    <div id="auth">
        <button id="btnLogin">Sign in with Google</button>
        <span id="who" class="pill" style="display:none;"></span>
    </div>

    <hr/>

    <div id="recorder" style="display:none;">
        <div class="row">
            <button id="btnStart">Start recording</button>
            <button id="btnStop" disabled>Stop</button>
            <span id="timer" class="note">00:00 / 00:60</span>
        </div>

        <audio id="player" controls style="width:100%; display:none;"></audio>

        <div class="row">
            <button id="btnUpload" disabled>Upload</button>
            <progress id="prog" value="0" max="100" style="display:none;"></progress>
        </div>

        <p class="note">
            Trouble on iPhone/Safari? You can pick a file instead:
            <input id="pick" type="file" accept="audio/*" capture="user" />
        </p>

        <p id="msg" class="note"></p>
    </div>
</div>

<!-- Firebase (script-tag build) -->
<script type="module">
    // --- Firebase SDKs ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
    import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-storage.js";

    // --- Your config (from console) ---
    const firebaseConfig = {
        apiKey: "AIzaSyDUIdVPKOCDsmOuoet6NofXoJzleiXMtHw",
        authDomain: "language-academy-3e1de.firebaseapp.com",
        projectId: "language-academy-3e1de",
        storageBucket: "language-academy-3e1de.firebasestorage.app",
        messagingSenderId: "849327205750",
        appId: "1:849327205750:web:2de0e6ed20c55d4f8d9e57",
        measurementId: "G-0T84WTTXRV"
    };

    // --- Init ---
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const storage = getStorage(app);

    // --- UI refs ---
    const btnLogin = document.getElementById("btnLogin");
    const who = document.getElementById("who");
    const recorderBox = document.getElementById("recorder");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnUpload = document.getElementById("btnUpload");
    const timerEl = document.getElementById("timer");
    const player = document.getElementById("player");
    const prog = document.getElementById("prog");
    const msg = document.getElementById("msg");
    const picker = document.getElementById("pick");

    // --- Auth ---
    btnLogin.onclick = async () => {
        await signInWithPopup(auth, new GoogleAuthProvider());
    };

    onAuthStateChanged(auth, (u) => {
        if (u) {
            who.style.display = "inline-block";
            who.textContent = u.email || u.uid;
            recorderBox.style.display = "block";
            btnLogin.style.display = "none";
        } else {
            who.style.display = "none";
            recorderBox.style.display = "none";
            btnLogin.style.display = "inline-block";
        }
    });

    // --- Recorder state ---
    let mediaRecorder = null;
    let chunks = [];
    let blob = null;
    let tick = null;
    const LIMIT_SECONDS = 60;

    function fmt(n) { return String(n).padStart(2, "0"); }

    function setMsg(text, klass = "note") {
        msg.className = klass;
        msg.textContent = text || "";
    }

    // --- Start recording ---
    btnStart.onclick = async () => {
        try {
            setMsg("");
            chunks = [];
            blob = null;
            player.style.display = "none";
            btnUpload.disabled = true;

            // Prefer Opus WebM; Safari falls back to default
            const mime = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
                ? "audio/webm;codecs=opus"
                : undefined;

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);

            let elapsed = 0;
            timerEl.textContent = "00:00 / 00:60";
            tick = setInterval(() => {
                elapsed += 1;
                timerEl.textContent = `${fmt(Math.floor(elapsed/60))}:${fmt(elapsed%60)} / 00:60`;
                if (elapsed >= LIMIT_SECONDS) btnStop.click();
            }, 1000);

            mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };
            mediaRecorder.onstop = () => {
                clearInterval(tick);
                // stop mic
                stream.getTracks().forEach(t => t.stop());
                blob = new Blob(chunks, { type: mediaRecorder.mimeType || "audio/webm" });
                player.src = URL.createObjectURL(blob);
                player.style.display = "block";
                btnUpload.disabled = false;
            };

            mediaRecorder.start(100); // gather in small chunks
            btnStart.disabled = true;
            btnStop.disabled = false;
        } catch (e) {
            setMsg("Mic access failed. On iPhone use the file picker below.", "warn");
            console.error(e);
        }
    };

    // --- Stop recording ---
    btnStop.onclick = () => {
        try {
            btnStop.disabled = true;
            btnStart.disabled = false;
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
        } catch {}
    };

    // --- Picker fallback (iOS etc.) ---
    picker.onchange = (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        blob = file;
        player.src = URL.createObjectURL(file);
        player.style.display = "block";
        btnUpload.disabled = false;
        setMsg("");
    };

    // --- Upload ---
    btnUpload.onclick = async () => {
        try {
            setMsg("");
            if (!auth.currentUser) {
                setMsg("Please sign in first.", "warn");
                return;
            }
            if (!blob) {
                setMsg("No audio to upload.", "warn");
                return;
            }
            // Whisper max ~25MB; keep headroom
            if (blob.size > 24 * 1024 * 1024) {
                setMsg("File is larger than 24MB. Please record again.", "warn");
                return;
            }

            // Name based on time; pick extension from blob.type when possible
            const ext = blob.type.includes("mp4") ? "m4a"
                      : blob.type.includes("ogg") ? "ogg"
                      : blob.type.includes("webm") ? "webm"
                      : "webm";
            const ts = new Date();
            const stamp = ts.toISOString().replace(/[:.]/g, "").slice(0, 15); // YYYY-MM-DDTHHMMSS â†’ compact
            const path = `pron_uploads/${auth.currentUser.uid}/${stamp}.${ext}`;

            const r = ref(storage, path);
            const task = uploadBytesResumable(r, blob, { contentType: blob.type || "audio/webm" });

            prog.style.display = "block";
            prog.value = 0;

            task.on("state_changed",
                (s) => {
                    const pct = Math.round((s.bytesTransferred / s.totalBytes) * 100);
                    prog.value = pct;
                },
                (err) => {
                    console.error(err);
                    setMsg("Upload failed. Please try again.", "err");
                    prog.style.display = "none";
                },
                async () => {
                    prog.value = 100;
                    const url = await getDownloadURL(task.snapshot.ref);
                    setMsg("Uploaded! You can close this page now.", "ok");
                    // Optional: show URL (private by rules; token grants access)
                    console.log("downloadURL:", url);
                    btnUpload.disabled = true;
                }
            );
        } catch (e) {
            console.error(e);
            setMsg("Unexpected error during upload.", "err");
        }
    };
</script>
</body>
</html>
